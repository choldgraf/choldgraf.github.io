{"version":1,"kind":"Notebook","sha256":"afd6c7a229dae72c60b7242468f04e060f8caa35ac8551dac0286e43db29f51b","slug":"blog.2016.2016-07-02-fft-time","location":"/blog/2016/2016-07-02-fft_time.ipynb","dependencies":[],"frontmatter":{"title":"The beauty of computational efficiency","tags":["python","programming","computation","efficiency","fft"],"date":"2016-07-02","kernelspec":{"name":"python3","display_name":"Python 3","language":"python"},"authors":[{"id":"chris","nameParsed":{"literal":"Chris Holdgraf","given":"Chris","family":"Holdgraf"},"name":"Chris Holdgraf","orcid":"0000-0002-2391-0678","affiliations":["affiliations-myst-generated-uid-0","affiliations-myst-generated-uid-1"],"twitter":"choldgraf","github":"choldgraf","url":"https://chrisholdgraf.com"}],"github":"https://github.com/choldgraf/choldgraf.github.io","affiliations":[{"name":"2i2c","url":"https://2i2c.org","id":"affiliations-myst-generated-uid-0"},{"name":"Project Jupyter","url":"https://jupyter.org","id":"affiliations-myst-generated-uid-1"}],"abbreviations":{"LF":"The Linux Foundation","JF":"The Jupyter Foundation","JEC":"Jupyter Executive Council","JFB":"The Jupyter Foundation Board","SSC":"Software Steering Council"},"numbering":{"title":{"offset":2}},"edit_url":"https://github.com/choldgraf/choldgraf.github.io/blob/main/blog/2016/2016-07-02-fft_time.ipynb","exports":[{"format":"ipynb","filename":"2016-07-02-fft_time.ipynb","url":"/build/2016-07-02-fft_time-5a5dfdba77b28e7045ba4dd89df04a7c.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"heading","depth":2,"position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"children":[{"type":"text","value":"The beauty of computational efficiency and the FFT","position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"key":"yPXIf0L6gG"}],"identifier":"the-beauty-of-computational-efficiency-and-the-fft","label":"The beauty of computational efficiency and the FFT","html_id":"the-beauty-of-computational-efficiency-and-the-fft","implicit":true,"key":"pQGI77HgYx"},{"type":"paragraph","position":{"start":{"line":31,"column":1},"end":{"line":31,"column":1}},"children":[{"type":"text","value":"When we discuss “computational efficiency”, you often hear people throw around phrases like ","position":{"start":{"line":31,"column":1},"end":{"line":31,"column":1}},"key":"VpdcerlO53"},{"type":"inlineMath","value":"O(n^2)","position":{"start":{"line":31,"column":1},"end":{"line":31,"column":1}},"html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>","key":"LJwZMNLAMQ"},{"type":"text","value":" or ","position":{"start":{"line":31,"column":1},"end":{"line":31,"column":1}},"key":"m2Dn1rkP61"},{"type":"inlineMath","value":"O(nlogn)","position":{"start":{"line":31,"column":1},"end":{"line":31,"column":1}},"html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>","key":"rJtJkIipYM"},{"type":"text","value":". We talk about them in the abstract, and it can be hard to appreciate what these distinctions mean and how important they are. So let’s take a quick look at what computational efficiency looks like in the context of a very famous algorithm: The Fourier Transform.","position":{"start":{"line":31,"column":1},"end":{"line":31,"column":1}},"key":"jKncRYdDPT"}],"key":"qAjsZkk7oV"},{"type":"heading","depth":3,"position":{"start":{"line":33,"column":1},"end":{"line":33,"column":1}},"children":[{"type":"text","value":"A short primer on the Fourier Transform","position":{"start":{"line":33,"column":1},"end":{"line":33,"column":1}},"key":"YUaObPy2jj"}],"identifier":"a-short-primer-on-the-fourier-transform","label":"A short primer on the Fourier Transform","html_id":"a-short-primer-on-the-fourier-transform","implicit":true,"key":"bnYylE7lio"},{"type":"paragraph","position":{"start":{"line":34,"column":1},"end":{"line":34,"column":1}},"children":[{"type":"text","value":"Briefly, A Fourier Transform is used for uncovering the spectral information that is present in a signal. AKA, it tells us about oscillatory components in the signal, and has ","position":{"start":{"line":34,"column":1},"end":{"line":34,"column":1}},"key":"I5xPiJspPY"},{"type":"link","url":"http://dsp.stackexchange.com/questions/69/why-is-the-fourier-transform-so-important","position":{"start":{"line":34,"column":1},"end":{"line":34,"column":1}},"children":[{"type":"text","value":"a wide range","position":{"start":{"line":34,"column":1},"end":{"line":34,"column":1}},"key":"Sn6OPl4YUN"}],"urlSource":"http://dsp.stackexchange.com/questions/69/why-is-the-fourier-transform-so-important","key":"qJSfeFnswi"},{"type":"text","value":" of uses in communications, signal processing, and even neuroscience analysis.","position":{"start":{"line":34,"column":1},"end":{"line":34,"column":1}},"key":"PUStjsbINg"}],"key":"Y9C3Fxzxu1"},{"type":"paragraph","position":{"start":{"line":36,"column":1},"end":{"line":36,"column":1}},"children":[{"type":"text","value":"Here’s a ","position":{"start":{"line":36,"column":1},"end":{"line":36,"column":1}},"key":"OVoFPXs01N"},{"type":"link","url":"https://www.quora.com/What-is-an-intuitive-way-of-explaining-how-the-Fourier-transform-works","position":{"start":{"line":36,"column":1},"end":{"line":36,"column":1}},"children":[{"type":"text","value":"Quora post","position":{"start":{"line":36,"column":1},"end":{"line":36,"column":1}},"key":"fVvm4Zlxu4"}],"urlSource":"https://www.quora.com/What-is-an-intuitive-way-of-explaining-how-the-Fourier-transform-works","key":"ylI4WHriZT"},{"type":"text","value":" that discusses Fourier Transforms more generally. The first explanation is fantastic and full of history and detail.","position":{"start":{"line":36,"column":1},"end":{"line":36,"column":1}},"key":"ljGZZNum0O"}],"key":"Lw3YEDhxKj"},{"type":"paragraph","position":{"start":{"line":38,"column":1},"end":{"line":38,"column":1}},"children":[{"type":"text","value":"The challenge with the Fourier Transform is that it can take a really long time to compute. If you h ave a signal of length ","position":{"start":{"line":38,"column":1},"end":{"line":38,"column":1}},"key":"zTmNsjEyQs"},{"type":"inlineMath","value":"n","position":{"start":{"line":38,"column":1},"end":{"line":38,"column":1}},"html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>","key":"riCRsLqgAq"},{"type":"text","value":", then you’re calculating ","position":{"start":{"line":38,"column":1},"end":{"line":38,"column":1}},"key":"WZJEl09PzT"},{"type":"inlineMath","value":"n","position":{"start":{"line":38,"column":1},"end":{"line":38,"column":1}},"html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>","key":"BsrK2G5EX5"},{"type":"text","value":" Fourier components for each point in the (length ","position":{"start":{"line":38,"column":1},"end":{"line":38,"column":1}},"key":"yN5eTTOMOl"},{"type":"inlineMath","value":"n","position":{"start":{"line":38,"column":1},"end":{"line":38,"column":1}},"html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>","key":"CTVlQ3WRun"},{"type":"text","value":") signal. This means that the number of operations required to calculate a fourier transform is ","position":{"start":{"line":38,"column":1},"end":{"line":38,"column":1}},"key":"eJ4ixy9CNI"},{"type":"inlineMath","value":"n * n","position":{"start":{"line":38,"column":1},"end":{"line":38,"column":1}},"html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n * n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4653em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>","key":"GzxGweXMXa"},{"type":"text","value":" or ","position":{"start":{"line":38,"column":1},"end":{"line":38,"column":1}},"key":"GQtTYuqZ64"},{"type":"inlineMath","value":"O(n^2)","position":{"start":{"line":38,"column":1},"end":{"line":38,"column":1}},"html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>","key":"okiUlrrd4g"},{"type":"text","value":".","position":{"start":{"line":38,"column":1},"end":{"line":38,"column":1}},"key":"mztfFP1z63"}],"key":"NK3OBLpyGV"},{"type":"paragraph","position":{"start":{"line":40,"column":1},"end":{"line":40,"column":1}},"children":[{"type":"text","value":"For a quick intuition into what a difference this makes. Consider two signals, one of length 10, and the other of length 100. Since the Fourier Transform is ","position":{"start":{"line":40,"column":1},"end":{"line":40,"column":1}},"key":"rEKB6zjTnO"},{"type":"inlineMath","value":"O(n^2)","position":{"start":{"line":40,"column":1},"end":{"line":40,"column":1}},"html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>","key":"wILZl8l8Eh"},{"type":"text","value":", the length 100 signal will take ","position":{"start":{"line":40,"column":1},"end":{"line":40,"column":1}},"key":"NegbDSGw28"},{"type":"emphasis","position":{"start":{"line":40,"column":1},"end":{"line":40,"column":1}},"children":[{"type":"text","value":"2 orders of magnitude","position":{"start":{"line":40,"column":1},"end":{"line":40,"column":1}},"key":"VcaftxyP10"}],"key":"shBAgwtb64"},{"type":"text","value":" longer to compute, even though it is only ","position":{"start":{"line":40,"column":1},"end":{"line":40,"column":1}},"key":"EHITVCGkQH"},{"type":"emphasis","position":{"start":{"line":40,"column":1},"end":{"line":40,"column":1}},"children":[{"type":"text","value":"1 order of magnitude longer in length","position":{"start":{"line":40,"column":1},"end":{"line":40,"column":1}},"key":"DI8CGBCz2G"}],"key":"i3SKDgKuiW"},{"type":"text","value":".","position":{"start":{"line":40,"column":1},"end":{"line":40,"column":1}},"key":"BOYIsfXRqv"}],"key":"FQ58ZXbekI"},{"type":"paragraph","position":{"start":{"line":42,"column":1},"end":{"line":42,"column":1}},"children":[{"type":"text","value":"Think this isn’t a big deal? Let’s see what happens when the signal gets longer. First off, a very short signal:","position":{"start":{"line":42,"column":1},"end":{"line":42,"column":1}},"key":"UpaobgYCpf"}],"key":"vu3xUXzici"}],"key":"GYRHXLyY1h"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"# We can use the `time` and the `numpy` module to time how long it takes to do an FFT\nfrom time import time\nimport numpy as np\nimport seaborn as sns\nsns.set_style('white')\n\n# For a signal of length ~1000. Say, 100ms of a 10KHz audio sample.\nsignal = np.random.randn(1009)\nstart = time()\n_ = np.fft.fft(signal)\nstop = time()\nprint('It takes {} seconds to do the FFT'.format(stop-start))","key":"t34aKVWxKf"},{"type":"output","id":"POC-mmLKQfFQMaLAM0P_j","data":[],"key":"u0TKbSoUox"}],"key":"RudhWK4uti"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"That’s not too bad - ~.003 seconds is pretty fast. But here’s where the ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"eNyLIMsUfD"},{"type":"inlineMath","value":"O(n^2)","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>","key":"Gqn3MnsemP"},{"type":"text","value":" thing really gets us...","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"C4QaQT8Ed6"}],"key":"t9fjo13NuD"}],"key":"HYIRVCH6Tl"},{"type":"block","kind":"notebook-code","data":{"collapsed":true,"jupyter":{"outputs_hidden":true}},"children":[{"type":"code","lang":"python","executable":true,"value":"# We'll test out how long the FFT takes for a few lengths\ntest_primes = [11, 101, 1009, 10009, 100019]","key":"HjatkMvTKc"},{"type":"output","id":"qCE6gvGIjYNGOwAImpK-4","data":[],"key":"iJceiB62cZ"}],"key":"ezeOngh3ZG"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"# Let's try a few slightly longer signals\nfor i_length in test_primes:\n    # Calculate the number of factors for this length (we'll see why later)\n    factors = [ii for ii in range(1, 1000) if i_length % ii == 0]\n    # Generate a random signal w/ this length\n    signal = np.random.randn(i_length)\n    # Now time the FFT\n    start = time()\n    _ = np.fft.fft(signal)\n    stop = time()\n    print('With data of length {} ({} factors), it takes {} seconds to do the FFT'.format(\n            i_length, len(factors), stop-start))","key":"AkqNfxxVnT"},{"type":"output","id":"84MkDStsnc87AyuAv2FKA","data":[],"key":"OthrTdy4hE"}],"key":"XnyEauMRSP"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Whoah wait a sec, that last one took way longer than everything else. We increased the length of the data by a factor of 10, but the time it took went up by a factor of 100. Not good. That means that if we want to perform an FFT on a signal that was 10 times longer, it’d take us about 42 minutes. 100 times longer? That’d take ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"t9xThLNv0W"},{"type":"emphasis","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"~3 days.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"pLOK8jv1no"}],"key":"JESGOpkzZg"}],"key":"TgZcNsYCuk"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Given how important the Fourier Transform is, it’d be great if we could speed it up somehow.","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"pod4lbWdjx"}],"key":"jnXOnTvjbw"},{"type":"blockquote","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"emphasis","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"You’ll notice that I chose a very particular set of numbers above. Specifically, I chose numbers that were primes (or nearly primes) meaning that they couldn’t be broken down into products of smaller numbers. That turns out to be really important in allowing the FFT to do its magic. When your signal length is a prime number, then you don’t gain any speedup from the FFT, as I’ll show below.","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"OSGsK9HHz3"}],"key":"oGhChMVNlY"}],"key":"hvMUSL3Eer"}],"key":"hBw8SBaElJ"},{"type":"heading","depth":3,"position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"Enter the Fast Fourier Transform","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"NKWoMA87Ie"}],"identifier":"enter-the-fast-fourier-transform","label":"Enter the Fast Fourier Transform","html_id":"enter-the-fast-fourier-transform","implicit":true,"key":"BUVWjl6SrT"},{"type":"paragraph","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"children":[{"type":"text","value":"The Fast Fourier Transform (FFT) is one of the most important algorithms to come out of the last century because it drastically speeds up the performance of the Fourier Transform. It accomplishes this by breaking down all those ","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"key":"QwZ9lkX7VK"},{"type":"inlineMath","value":"n^2","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"html":"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>","key":"xFQbUlyMcS"},{"type":"text","value":" computations into a smaller number of computations, and then putting them together at the end to get the same result. This is called ","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"key":"ia0wnompBB"},{"type":"strong","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"children":[{"type":"text","value":"factorizing","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"key":"QCu2E0rSp7"}],"key":"Z037wAuC56"},{"type":"text","value":".","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"key":"dFH8n8ihmH"}],"key":"u29Gg9WtFR"},{"type":"paragraph","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"You can think of factorizing like trying to move a bunch of groceries from your car to your fridge. Say you have 20 items in your car. One way to do this is to individually take each item, pull it from the car, walk to the house, place it in the fridge. It’d take you 20 trips to do this. Factorizing is like putting your 20 items into 2 grocery bags. Now you only need to make 2 trips to the house - one for each grocery bag. The first approach requires 20 trips to the house, and the second requires 2 trips. You’ve just reduced the number of trips by an order of magnitude!","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"A6M7ABGPMO"}],"key":"QTxzitdnBI"},{"type":"paragraph","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"children":[{"type":"text","value":"The FFT accomplishes its factorization by recognizing that signals of a certain length can be broken down (factorized) into smaller signals. How many smaller signals? Well, that depends on the length of the original signal. If a number has many ","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"DeMfHUEXo8"},{"type":"emphasis","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"children":[{"type":"text","value":"factors","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"WW4V082qMe"}],"key":"KmfkpGhmvg"},{"type":"text","value":", it means that it can be broken down into a product of many different, smaller, signals.","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"y3tdWNNVZG"}],"key":"l5Dwf5LEqZ"},{"type":"paragraph","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"In practice, this means that if the input to an FFT has a lot of factors, then you gain a bigger speedup from the FFT algorithm. On one end, a signal with a length == a power of two will have a ton of factors, and yield the greatest speedups. A signal with length == a prime number will be the slowest because it has no factors. Below is a quick simulation to see how much of a difference this makes.","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"lezpN3FncP"}],"key":"oCrtPTIkN9"},{"type":"blockquote","position":{"start":{"line":16,"column":1},"end":{"line":19,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"text","value":"Here are some useful links explaining Fourier Transforms, as well as the FFT:","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"zo5B7m9NLe"}],"key":"CffaIaTvpu"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":17,"column":1},"end":{"line":19,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"link","url":"https://www.quora.com/What-is-an-intuitive-explanation-of-the-FFT-algorithm","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"text","value":"A Quora post","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"DOg0zVpDvR"}],"urlSource":"https://www.quora.com/What-is-an-intuitive-explanation-of-the-FFT-algorithm","key":"tZIk8nud0j"},{"type":"text","value":" with some great answers on the intuition behind the Fast Fourier Transform.","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"fhe0tiZsQv"}],"key":"MK6ScNAfF1"},{"type":"listItem","spread":true,"position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"link","url":"https://en.wikipedia.org/wiki/Fast_Fourier_transform","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"The wikipedia entry","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"N9mB7M7CfV"}],"urlSource":"https://en.wikipedia.org/wiki/Fast_Fourier_transform","data":{"page":"Fast_Fourier_transform","wiki":"https://en.wikipedia.org/","lang":"en"},"internal":false,"protocol":"wiki","key":"ma1y8hv5nu"},{"type":"text","value":" for FFTs also has some nice links.","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"dAFX1OYUP4"}],"key":"qZeU7DXEc0"},{"type":"listItem","spread":true,"position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"children":[{"type":"link","url":"https://jakevdp.github.io/blog/2013/08/28/understanding-the-fft/","position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"children":[{"type":"text","value":"A post on the FFT","position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"key":"lKNvqcSKqE"}],"urlSource":"https://jakevdp.github.io/blog/2013/08/28/understanding-the-fft/","key":"c7PvCDLOCG"},{"type":"text","value":" from Jake Vanderplas is also a great explanation of how it works.","position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"key":"U4jeuuVW4S"}],"key":"cRy5sMHYQt"}],"key":"B9I7ol8Lkv"}],"key":"LYWlDocV0z"}],"key":"lBwI76SswX"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"import pandas as pd\nfrom sklearn import linear_model\nfrom matplotlib import pyplot as plt\n%matplotlib inline","key":"nQZltY8cjK"},{"type":"output","id":"7RBu_YHoQFsRZyZQcmz5K","data":[],"key":"OTsNZRLYgx"}],"key":"WGLUcibD27"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"The beautiful efficiency of the FFT","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"brWBSi4hNZ"}],"identifier":"the-beautiful-efficiency-of-the-fft","label":"The beautiful efficiency of the FFT","html_id":"the-beautiful-efficiency-of-the-fft","implicit":true,"key":"shtQD8UrWm"},{"type":"paragraph","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"text","value":"To see what the FFT’s efficiency looks like, we’ll simulate data of different lengths and see how long it takes to compute the FFT at each length. We’ll create a random vector of gaussian noise ranging from length 1 to 10,000. For each vector, we’ll compute the FFT, and time how long it took to compute. I’ve already taken the liberty of doing this (repeated 3 times, and then averaged together). Those times are stored in fft_times.csv.","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"pjaODG8dvA"}],"key":"FUSus8ZCB2"}],"key":"RlTYxaaqIJ"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"# Let's read in the data and see how it looks\ndf = pd.read_csv('../data/fft_times.csv', index_col=0)\ndf = df.apply(pd.to_numeric)\ndf = df.mean(0).to_frame('time')\ndf.index = df.index.astype(int)\ndf['length'] = df.index.values","key":"oaWGxnDjZq"},{"type":"output","id":"0XQvj8SXgFvyZPGQcctid","data":[],"key":"sDYesgUuD3"}],"key":"FEndIoFxfH"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"# First off, it's clear that computation time grows nonlinearly with signal length\ndf.plot('length', 'time', figsize=(10, 5))","key":"cUOrDGjFvZ"},{"type":"output","id":"0UkpIQRXksnxwcpY1S96Z","data":[{"output_type":"execute_result","execution_count":27,"metadata":{},"data":{}},{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"dd7fcfa07484d180f1d5a9644f57618f","path":"/build/dd7fcfa07484d180f1d5a9644f57618f.png"}}}],"key":"cG7kI8LxpL"}],"key":"k61BU9GrMt"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"# However, upon closer inspection, it's clear that there's much variability\nwinsize = 500\ni = 0\nj = i + winsize\ndf.iloc[i:j]['time'].plot(figsize=(10, 5))","key":"ldBUYmaVEU"},{"type":"output","id":"G149JHvxVa_xUAsGbOJKq","data":[{"output_type":"execute_result","execution_count":28,"metadata":{},"data":{}},{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"ab69d424d93ac78b89c178315319af35","path":"/build/ab69d424d93ac78b89c178315319af35.png"}}}],"key":"IRCRIGje7a"}],"key":"SRHygLzIKF"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"As you can see, there appear to be multiple trends in the data. There seems to be a “most inefficient” line of growth in the data, as well as a “more efficient” and a “most efficient” trend. These correspond to lengths that are particularly good for an FFT.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"LT9O9RdTEG"}],"key":"knYOKvdtDy"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"We can use regression to find the “linear” relationship between length of signal and time of FFT. However, if there are any trends in the data that are ","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"sCBwZ1hDLt"},{"type":"strong","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"nonlinear","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"zAUryaCmNU"}],"key":"P0tBuVMGKY"},{"type":"text","value":", then they should show up as errors in the regression model. Let’s see if that happens...","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"MhUR1f3bf9"}],"key":"zEAXFzZBGZ"}],"key":"sN4SG0TsJ8"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"# We'll use a regression model to try and fit how length predicts time\nmod = linear_model.LinearRegression()\nxfit = df['length']\nxfit = np.vstack([xfit, xfit**2, xfit**3, xfit**4]).T\nyfit = df['time'].reshape([-1, 1])","key":"pFbUJC05ka"},{"type":"output","id":"Kv-Dv2K2hpfaHmj-yi_T2","data":[],"key":"vMz67FTjYI"}],"key":"AknNH4ByC8"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"# Now fit to our data, and calculate the error for each datapoint\nmod.fit(xfit, yfit)\ndf['ypred'] = mod.predict(xfit)\ndf['diff'] = df['time'] - df.ypred","key":"j1Z03LhagJ"},{"type":"output","id":"gZRLRqx6GESQgZx6eMCKp","data":[],"key":"T5LCCEuxGb"}],"key":"ebDwGUHjqy"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"# As the length grows, the trends in the data begin to diverge more and more\nax = df.plot('length', 'diff', kind='scatter',\n             style='.', alpha=.5, figsize=(10, 5))\nax.set_ylim([0, .05])\nax.set_title('Error of linear fit for varying signal lengths')","key":"KKLN36SOIN"},{"type":"output","id":"2Yjm9rFP7Qc1f_ykxXsSV","data":[{"output_type":"execute_result","execution_count":31,"metadata":{},"data":{}},{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"544c606f954f39d303d7bc6fc53bad45","path":"/build/544c606f954f39d303d7bc6fc53bad45.png"}}}],"key":"z2XQWCOTQz"}],"key":"yFpAXeXwF1"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"It looks like there are some clear components of the data that ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"K4IrCnhd7p"},{"type":"emphasis","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"don’t","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"b92dqf1r5G"}],"key":"XwpqHvxUQr"},{"type":"text","value":" follow a linear relationship. Moreover, this seems to be systematic. We clearly see several separate traces in the error plot, which means that there are patterns in the data that follow different non-linear trends.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"q6eoBy0Xi7"}],"key":"TXD87S8BFu"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"But we already know that the FFT efficiency will differ depending on the number of factors of the signal’s length. Let’s see if that’s related to the plot above...","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"Ykkzu7qMMN"}],"key":"t8WpirXP0K"}],"key":"vUf5cHA3oB"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"# We'll write a helper function that shows how many (<100) factors each length has\nfind_n_factors = lambda n: len([i for i in range(1, min(100, n-1)) if n % i == 0])\n\n# This tells us the number of factors for all lengths we tried\ndf['n_factors'] = df['length'].map(find_n_factors)\n\n# We now have a column that tells us how many factors each iteration had\ndf.tail()","key":"HxDO6YuNFq"},{"type":"output","id":"U6ZS6XvdIMx7Vk4rRoB_z","data":[{"output_type":"execute_result","execution_count":32,"metadata":{},"data":{"text/html":{"content":"<div>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>time</th>\n      <th>length</th>\n      <th>ypred</th>\n      <th>diff</th>\n      <th>n_factors</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>9995</th>\n      <td>0.031189</td>\n      <td>9995</td>\n      <td>0.035864</td>\n      <td>-0.004675</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>9996</th>\n      <td>0.000974</td>\n      <td>9996</td>\n      <td>0.035873</td>\n      <td>-0.034899</td>\n      <td>18</td>\n    </tr>\n    <tr>\n      <th>9997</th>\n      <td>0.012076</td>\n      <td>9997</td>\n      <td>0.035881</td>\n      <td>-0.023805</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>9998</th>\n      <td>0.080163</td>\n      <td>9998</td>\n      <td>0.035889</td>\n      <td>0.044274</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>9999</th>\n      <td>0.002135</td>\n      <td>9999</td>\n      <td>0.035897</td>\n      <td>-0.033763</td>\n      <td>6</td>\n    </tr>\n  </tbody>\n</table>\n</div>","content_type":"text/html"},"text/plain":{"content":"          time  length     ypred      diff  n_factors\n9995  0.031189    9995  0.035864 -0.004675          2\n9996  0.000974    9996  0.035873 -0.034899         18\n9997  0.012076    9997  0.035881 -0.023805          2\n9998  0.080163    9998  0.035889  0.044274          2\n9999  0.002135    9999  0.035897 -0.033763          6","content_type":"text/plain"}}}],"key":"oEfGyHbyGC"}],"key":"C5awchv3Hq"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Finally, we can plot time to compue the FFT as a function of the number of factors for that signal length.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"nNKuKE4rpM"}],"key":"jMKQnQKxN2"}],"key":"i2497yRmcV"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"# As we can see, the FFT time drops quickly as a function of the number of factors\nax = df.plot('n_factors', 'time', style=['.'], figsize=(10, 5), alpha=.1)\nax.set_xlim([0, 15])\nax.set_ylabel('Time for FFT (s)')\nax.set_title('Time of FFT for varying numbers of factors')","key":"VECGmlitRL"},{"type":"output","id":"S4cLd4F72CurEExFXpxlX","data":[{"output_type":"execute_result","execution_count":33,"metadata":{},"data":{}},{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"ef862789d3f5d2b2ba22f1792a762463","path":"/build/ef862789d3f5d2b2ba22f1792a762463.png"}}}],"key":"UZCTYDffFu"}],"key":"cWtUfZscSs"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"The fewer factors in the length of the signal, the longer the FFT takes.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"HTLQyfWV2p"}],"key":"qtLDrpYV46"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Finally, we can show how the length of computation time changes for each group of factors. We’ll plot the signal length along with the time to compute the FFT, this time colored by the number of factors for each point.","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"lMwMpgy3yz"}],"key":"fIRIzpJQ49"}],"key":"V4P9fc5OKP"},{"type":"block","kind":"notebook-code","data":{"collapsed":false,"jupyter":{"outputs_hidden":false}},"children":[{"type":"code","lang":"python","executable":true,"value":"# We'll plot two zoom levels to see the detail\nf, axs = plt.subplots(2, 1, figsize=(10, 5))\nvmin, vmax = 1, 18\nfor ax in axs:\n    ax = df.plot.scatter('length', 'time', c='n_factors', lw=0, cmap=plt.cm.get_cmap('RdYlBu', vmax),\n                                           figsize=(10, 10), vmin=vmin, vmax=vmax, ax=ax, alpha=.5)\n    ax.set_xlabel('Length of signal (samples)')\n    ax.set_ylabel('Time to complete FFT (s)')\n    ax.set_title('Time to compute the FFT, colored by n_factors')\n_ = plt.setp(axs, xlim=[0, df['length'].max()])\n_ = plt.setp(axs[0], ylim=[0, .2])\n_ = plt.setp(axs[1], ylim=[0, .005])\nplt.tight_layout()","key":"Gy4AZAGrzg"},{"type":"output","id":"D0yb81PszSylk5Sgw4xjQ","data":[{"output_type":"display_data","metadata":{},"data":{"image/png":{"content_type":"image/png","hash":"ace444efc0674da3499ed0e12a3fc1d2","path":"/build/ace444efc0674da3499ed0e12a3fc1d2.png"}}}],"key":"ih2EgzegIs"}],"key":"sCwydglPcO"},{"type":"block","kind":"notebook-content","data":{},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Each of those colored traces spreading upwards represents a particular strategy that the FFT uses for that number of factors. As you can see, the FFT will take a lot longer (and scales exponentially) with fewer factors (see the red lines). It takes much less time (and scales more linearly) with more factors (see the blue lines).","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"bupthjklml"}],"key":"jDiu79nMLU"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"And that right there is the beauty of methods like the FFT. They leverage the structure of mathematics to take a computation that goes on for days, and figure out how to do it in seconds.","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"S6TkmGvK8t"}],"key":"a7xD67syCT"}],"key":"LTYIALW8al"}],"key":"it7Kddhvj5"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Combining dates with analysis visualization in python","url":"/blog/2017/2017-11-02-dates-multiple-plots","group":"2017"},"next":{"title":"Could Brexit have happened by chance?","url":"/blog/2016/2016-07-08-voting-randomness","group":"2016"}}},"domain":"http://localhost:3000"}